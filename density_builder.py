

'''
This utility reads an h5 file produced by the PWAPIC code and .wvpck files generated by the Wavepack code and generates a cube file containing the time-dependent electronic density corresponding to the molecule whose dynamics has been computed using Wavepack. 
'''

import numpy as np
import math
import h5py as h5
import spherical_util as spher
import fortranformat as ff
'''
def cart_to_spher_array(x,y,z):
    r=(x**2+y**2+z**2)**0.5

    t=(r != 0)*np.arccos(z/(r+(r == 0)))

    f=(r != 0)*((x == 0)*( y > 0)*(np.pi/2.)+(x == 0)*( y < 0)*(3.*np.pi/2.)+(x!=0)*np.arctan2(y,x))

    f=f+2*np.pi*(f < 0)

    return r,t,f
def cart_to_spher(x,y,z):
    r=(x**2+y**2+z**2)**0.5

    if(r == 0):
        t=0
        f=0

    else:
        t=np.arccos(z/r)

        if(x == 0 and y > 0):
            f=np.pi/2.
        elif(x == 0 and y < 0):
            f=3.*np.pi/2.
        else:
            f=np.arctan2(y,x)

    if(f < 0):
        f=f+2*np.pi

    return r,t,f
def legendre(l,x):
    if l == 0:
        return 1
    elif l == 1:
        return x
    else:
        return ((2*l-1)*x*legendre(l-1,x)-(l-1)*legendre(l-2,x))/l

def associated_legendre_nonorm(l,m,x):

    sign=( -bool(m % 2 != 0) + bool(m % 2 == 0) )

    if(m == 0):
        return sign * legendre(l,x)

    elif( m > 0 and math.fabs(x) == 1):
        return 0

    elif( m > 0 ):
        return sign * ( ( l - m + 1 ) * x * associated_legendre_nonorm( l ,m-1 ,x ) - (l + m - 1) * associated_legendre_nonorm( l - 1 , m - 1 , x )) / ( 1 - x ** 2)**0.5
    else:
        return sign * associated_legendre_nonorm( l , -m , x )
 
#def associated_legendre ( l , m , x):

#    return ((2 * l + 1) * ( l - math.factorial(math.fabs(m))) / ( ( 4 * np.pi) * ( l + math.factorial(math.fabs(m))) ) )**0.5 * associated_legendre_nonorm( l , m , x )
#    return ()**0.5 *associated_legendre_nonorm( l , m , x )

def spherical_harmonics(thet,phi,l,ml):

    if( ml < 0 ):
        return 2**0.5 * spher.passociated_legendre( l , -ml , np.cos(thet) ) * np.sin(- ml * phi) ;
    elif( ml == 0):
        return spher.passociated_legendre( l , ml , np.cos(thet) )
    else:
        return 2**0.5 *  spher.passociated_legendre( l , ml , np.cos(thet) ) * np.cos( ml * phi) ;
def contraction_value(r,thet,phi,l,ml,zeta):
    
    radial=(r**l)*(np.exp(-zeta*r**2))
    return radial

def ao_value(x,y,z,nucl_index,nuc_coord,ao_index,bas_fun_type,cont_num,cont_zeta,cont_coeff):


    val=np.dot(cont_coeff,np.exp(-cont_zeta*r**2))
    val=0
    for i in np.arange(0,cont_num):
        zeta=cont_zeta[i]
        val=val+cont_coeff[i]*(np.exp(-zeta*r**2))
    print(val)
    return val*angular*(r**l)
'''
def mo_value(r,t,f,mo_index,nucl_index,nucl_coord,bas_fun_type,cont_num,cont_zeta,cont_coeff,lcao_num_array,lcao_coeff_array,angular):
    
    val=0

    lcao_num=len(lcao_num_array[mo_index])
    lcao_coeff=lcao_coeff_array[mo_index]
#    print(lcao_coeff_array.shape,lcao_coeff.shape)

    r2=np.outer(r,np.ones(max(cont_num)))

    coeff=np.sum(cont_coeff*np.exp(-cont_zeta*r2**2),axis=1)*angular*r**bas_fun_type.T[0]

    val=np.dot(lcao_coeff,coeff)
    return val

def cubegen(xmin,ymin,zmin,dx,dy,dz,nx,ny,nz,filename,data,array_val):
    data = h5.File(dataloc,'r')
    file=open(filename,"w")
    file.write("Cube file written using python density utility \n")
    file.write("LiH electronic density \n")
    file.write('{:5} {:11.6f} {:11.6f} {:11.6f} \n'.format(data['/nuclear_coord/num_of_nucl'][0],xmin,ymin,zmin))
    file.write('{:5} {:11.6f} {:11.6f} {:11.6f} \n'.format(nx,dx,0.000000,0.000000))
    file.write('{:5} {:11.6f} {:11.6f} {:11.6f} \n'.format(ny,0.000000,dy,0.000000))
    file.write('{:5} {:11.6f} {:11.6f} {:11.6f} \n'.format(nz,0.000000,0.000000,dz))

    for i in np.arange(0,data['/nuclear_coord/num_of_nucl'][0]):
        file.write('{:5} {:11.6f} {:11.6f} {:11.6f} {:11.6f} \n'.format(1,1.000000,data['/nuclear_coord/nucl_cartesian_array'][0][i][0],data['/nuclear_coord/nucl_cartesian_array'][0][i][1],data['/nuclear_coord/nucl_cartesian_array'][0][i][2]))
    data.close()

    lineformat=ff.FortranRecordWriter('(1E13.5)') 
    for ix in np.arange(0,nx):
        for iy in np.arange(0,ny):
            for iz in np.arange(0,nz):
#                file.write('{:13.5E}'.format(array_val[ix][iy][iz]))
                file.write(lineformat.write([array_val[ix][iy][iz]]))
                if( (iz + 1) % 6 == 0 and iz != 0):
                    file.write('\n')
            file.write('\n')

    file.close()
    

if __name__ == "__main__" :
    #BEGIN OF BENOIT'S DATA TREATMENT
    '''
    n_time=32
    nes=19
    ncont=150
    tgsize=1
    gsize=1
    time_index=1

    i = np.arange(0,n_time)
    j = np.arange(0,ncont)

    benoit_data=np.loadtxt("/Users/stephan/Desktop/Z_CI_coeff1275real_110219")
    benoit_data=np.delete(benoit_data,np.arange(0,2851*32,2851),0) 
    benoit_data=np.swapaxes(benoit_data.reshape((32,30,19,5,2)),1,2).reshape((32,19,150,2)) 
    benoit_data=np.swapaxes(benoit_data,1,2)   # => shape = (32,150,19,2)
    ccbenoit_data=benoit_data[:,:,:,0] + 1j*benoit_data[:,:,:,1] 
    cbenoit_data=ccbenoit_data[time_index]
    wvpck_data=cbenoit_data

    norm=np.sum(np.sum(np.abs(cbenoit_data)**2,axis=0))
    print(norm)
#    cbenoit_data=cbenoit_data/norm
    '''
    #END OF BENOIT'S DATA TREATMENT
    #BEGIN  WAVEPACK DATA TREATMENT
    n_times=3000
    total_time=30.00
    es0=10
    nes=8
    totes=18
    tgsize=512
    gsize=128
    time_index=1636
    wvpck_file_loc_prefix="/Users/Stephan/dox/Pi_pop_and_average_pos/neut_wf_0.0_"
    wvpck_file_loc_suffix=".wvpck"
    dt=total_time/n_times

    wvpck_data=np.zeros((nes,gsize),dtype=np.complex64)
    for i in np.arange(es0,totes):
        print("Opening file ",i)
        fileloc=wvpck_file_loc_prefix+str(i)+wvpck_file_loc_suffix
        temp=np.loadtxt(fileloc)
        temp2=(temp.T[2,:]+1j*temp.T[3,:]).reshape(n_times,gsize)
        wvpck_data[i-es0]=temp2[time_index]
    #END OF WAVEPACK DATA TREATMENT
    dataloc="/Users/Stephan/Desktop/pydensity/LiH_density_grid.h5"
#    dataloc="/Users/Stephan/Desktop/LiH_benoit_density.h5"

#    state_1_index=0 np.arange(0,nes)
#    state_2_index=0 np.arange(0,nes)
#    position_index=0
    val=0
    data = h5.File(dataloc,'r')
    n_mo=data['/electronic_struct_param/n_mo_closed'][0]+data['/electronic_struct_param/n_mo_occ'][0]
    nucl_index=np.asarray(data['/basis_set_info/nucleus_basis_func'])
    nucl_coord=np.asarray(data['/nuclear_coord/nucl_cartesian_array'])
    bas_fun_type=np.asarray(data['/basis_set_info/basis_func_type'])
    cont_num=np.asarray(data['/basis_set_info/contraction_number'])
    cont_zeta=np.asarray(data['/basis_set_info/contraction_zeta'])
    cont_coeff=np.asarray(data['/basis_set_info/contraction_coeff'])
    lcao_coeff_array=np.asarray(data['/lcao_coeff/lcao_mo_coeff']) 
    lcao_num_array=np.asarray(np.asarray(data['/lcao_coeff/lcao_mo_coeff']))
    tran_den_mat=np.asarray(data['/lcao_coeff/tran_den_mat_mo'])
    n_states_neut=data['/electronic_struct_param/n_states_neut'][0]
    data.close()

    xmin=-10.0
    ymin=-10.0
    zmin=-10.0
    dx=0.416
    dy=0.416
    dz=0.416
    nx=64
    ny=64
    nz=64
    cube_array=np.zeros((nx,ny,nz))
    for irp in np.arange(0,gsize):
        ir=int(irp*tgsize/gsize)
        print("Computing density at position",irp)
        tdm=np.zeros((n_mo,n_mo))
        ##BENOIT DATA AVERGAGING
        #for icont in np.arange(0,ncont):
#        for ies in np.arange(es0,nes):
#            tdm=tdm+abs(wvpck_data[icont][ies])**2*tran_den_mat[ir][ies*n_states_neut+ies].reshape((n_mo,n_mo))
#            for jes in np.arange(ies+1,nes):
#                    print(ies,jes,"are the es")
#                tdm=tdm+2*((wvpck_data[icont][ies]*wvpck_data[icont][jes].conjugate()).real)*tran_den_mat[ir][ies*n_states_neut+jes].reshape((n_mo,n_mo))
#        tdm=tdm/norm

#        print("tdm computation done")
        ##END OF BENOIT DATA AVERGAGING
        ##WAVEPACK DATA TREATMENT
        for ies in np.arange(0,nes):
            tdm=tdm+abs(wvpck_data[ies][irp])**2*tran_den_mat[ir][(ies+es0)*n_states_neut+(ies+es0)].reshape((n_mo,n_mo))
            for jes in np.arange(ies+1,nes):
#                print(ies,jes,"are the es")
                tdm=tdm+2*((wvpck_data[ies][irp]*wvpck_data[jes][irp].conjugate()).real)*tran_den_mat[ir][(ies+es0)*n_states_neut+(jes+es0)].reshape((n_mo,n_mo))
#                            tdm=tran_den_mat[ir][state_1_index*n_states_neut+state_2_index].reshape((n_mo,n_mo))
        ##WAVEPACK DATA TREATMENT
        for ix in np.arange(0,nx):
#            print(ix,"/",nx)
            x=xmin+ix*dx
            for iy in np.arange(0,ny):
                y=ymin+iy*dy
                for iz in np.arange(0,nz):
                    z=zmin+iz*dz

                    val=0
                    lcao_num=len(lcao_num_array[ir][0])
                    coord=np.array([x,y,z])
                    coordp=coord-nucl_coord[ir][nucl_index-1]
                    rp=np.zeros(lcao_num)
                    tp=np.zeros(lcao_num)
                    fp=np.zeros(lcao_num)
                    xp=coordp.T[0]
                    yp=coordp.T[1]
                    zp=coordp.T[2]
                    xp=xp.copy(order='C')
                    yp=yp.copy(order='C')
                    zp=zp.copy(order='C')
                    rp=rp.copy(order='C')
                    tp=tp.copy(order='C')
                    fp=fp.copy(order='C')

                    spher.pcart_to_spher(xp,yp,zp,rp,tp,fp)
                    r,t,f=rp.T,tp.T,fp.T
                    angular=np.zeros(lcao_num)
                    l=bas_fun_type.T[0]
                    ml=bas_fun_type.T[1]
                    l=l.copy(order='C')
                    ml=ml.copy(order='C')
                    angular=angular.copy(order='C')
                    spher.pspher_harmo(t,f,l,ml,angular)
    
                    i=np.arange(0,n_mo)
#                    j=np.arange(0,n_mo)
                    phii=mo_value(r,t,f,i,nucl_index,nucl_coord[ir],bas_fun_type,cont_num,cont_zeta,cont_coeff,lcao_num_array[ir],lcao_coeff_array[ir],angular)
#                    phij=mo_value(r,t,f,j,nucl_index,nucl_coord[position_index],bas_fun_type,cont_num,cont_zeta,cont_coeff,lcao_num_array[position_index],lcao_coeff_array[position_index],angular)
                    # BENOIT DATA TREATMENT
#                    val=mo_value(r,t,f,0,nucl_index,nucl_coord[ir],bas_fun_type,cont_num,cont_zeta,cont_coeff,lcao_num_array[ir],lcao_coeff_array[ir],angular)
                    '''
                    tdm=tran_den_mat[position_index].reshape(nes**2,n_mo,n_mo)  #  nes x nmo x nmo
                    tdm=np.swapaxes(tdm,0,1)  #  nmo x nes x nmo
                    temp=np.tensordot(tdm,phij,1)
                    temp=temp.reshape(n_mo,nes,nes)
                    temp2=np.tensordot(phii.T,temp,1)
                    temp3=np.tensordot(np.conjugate(cbenoit_data),temp2,1)
                    temp3=np.swapaxes(temp3,0,1)
                    temp4=np.tensordot(cbenoit_data,temp3,1)
                    
                    val=np.diagonal(temp4)
    
                    #val2=val[i,:,i]
                    fval=np.sum(val)
                    '''                
                    # END BENOIT DATA TREATMENT
                    val=np.dot(phii.T,np.matmul(tdm,phii))
    
    
#                    for i in np.arange(0,n_mo):
#                        for j in np.arange(0,n_mo):
    #                        val = val + tran_den_mat[position_index][state_1_index*n_states_neut+state_2_index][i*n_mo+j]*mo_value(r,t,f,i,nucl_index,nucl_coord[position_index],bas_fun_type,cont_num,cont_zeta,cont_coeff,lcao_num_array[position_index],lcao_coeff_array[position_index],angular)*mo_value(r,t,f,j,nucl_index,nucl_coord[position_index],bas_fun_type,cont_num,cont_zeta,cont_coeff,lcao_num_array[position_index],lcao_coeff_array[position_index],angular)
        #print(tran_den_mat[position_index][state_1_index*n_states_neut+state_2_index][i*n_mo+j],mo_value(x,y,z,position_index,j,nucl_index,nucl_coord[position_index],bas_fun_type,cont_num,cont_zeta,cont_coeff,lcao_num_array[position_index],lcao_coeff_array[position_index]))
                    #        print('{}/{}'.format(i*n_mo+j,n_mo**2))
        
                    cube_array[ix][iy][iz]=cube_array[ix][iy][iz]+val
#                    print(val,ix,iy,iz)
    
    target_file="/Users/stephan/Desktop/density_time_"+str(time_index)+"_recollision.cub"
    cubegen(xmin,ymin,zmin,dx,dy,dz,nx,ny,nz,target_file,dataloc,cube_array)
    
            
