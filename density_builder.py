'''
This utility reads an h5 file produced by the PWAPIC code and .wvpck files generated by the Wavepack code and generates a cube file containing the time-dependent electronic density corresponding to the molecule whose dynamics has been computed using Wavepack.
'''

import numpy as np
import math
import h5py as h5
import spherical_util as spher
import fortranformat as ff
import os
import pickle
import sys
import scipy as sp
from scipy import special


def intplushalf_gamma(n):
    return (np.arccos(-1)**0.5)*sp.special.factorial(2*n)/((4**n)*sp.special.factorial(n));

def mo_value(r,t,f,mo_index,nucl_index,nucl_coord,bas_fun_type,cont_num,cont_zeta,cont_coeff,lcao_num_array,lcao_coeff_array,angular):

    val=0

    lcao_num=lcao_num_array
    lcao_coeff=lcao_coeff_array[mo_index]
#    print(lcao_coeff_array.shape,lcao_coeff.shape)

    r2=np.outer(r,np.ones(max(cont_num)))

    coeff=np.sum(cont_coeff*np.exp(-cont_zeta*r2**2),axis=1)*angular*r**bas_fun_type.T[0]

    val=np.dot(lcao_coeff,coeff)

    return val


def cubegen(xmin,ymin,zmin,dx,dy,dz,nx,ny,nz,filename,array_val,nucl_coord):
    file=open(filename,"w")
    file.write("Cube file written using python density utility \n")
    file.write("Norbornadiene electronic density \n")
    file.write('{:5} {:11.6f} {:11.6f} {:11.6f} \n'.format(nucl_coord.shape[0],xmin,ymin,zmin))
    file.write('{:5} {:11.6f} {:11.6f} {:11.6f} \n'.format(nx,dx,0.000000,0.000000))
    file.write('{:5} {:11.6f} {:11.6f} {:11.6f} \n'.format(ny,0.000000,dy,0.000000))
    file.write('{:5} {:11.6f} {:11.6f} {:11.6f} \n'.format(nz,0.000000,0.000000,dz))

    for i in np.arange(0,nucl_coord.shape[0]):
        file.write('{:5} {:11.6f} {:11.6f} {:11.6f} {:11.6f} \n'.format(1,1.000000,nucl_coord[i][0],nucl_coord[i][1],nucl_coord[i][2]))

    lineformat=ff.FortranRecordWriter('(1E13.5)')
    for ix in np.arange(0,nx):
        for iy in np.arange(0,ny):
            for iz in np.arange(0,nz):
                file.write(lineformat.write([array_val[ix,iy,iz]]))
                if( (iz + 1) % 6 == 0 and iz != 0):
                    file.write('\n')
            file.write('\n')

    file.close()


def string_active_space_transformer(fn, inactive):
    '''
    from a grepped molcas file to the right vector
    fn :: filepath <- file with a list of occupations in the right order 222ud000
    '''
    with open(fn,'r') as f:
        content = f.readlines()

    inactive_string = '2'*inactive
    strings = [ inactive_string + x.replace('\n','') for x in content if x != '\n' ]

    print('\n\nThis file contains {} cases\n\n'.format(len(strings)))
    a = [ from_string_to_vector(x) for x in strings ]
    MO_index = []
    spin_state = []
    for x in strings:
        MO, spin = from_string_to_vector(x)
        MO_index = MO_index + MO
        spin_state = spin_state + spin
    MO_index_out = np.array(MO_index,dtype=np.int32)
    spin_state_out = np.array(spin_state,dtype=np.int32)
    return (MO_index_out,spin_state_out)


def from_string_to_vector(strin):
    '''
    from a string of occupation it get the two vectors MO_index and spin_state
    strin :: String <- '22222222222222222222222u000d002'
    '''
    MO_index = []
    spin_state = []
    for a,i in enumerate(strin): # for each character of this string
        if i == '2':
            MO_index.append(a)
            spin_state.append(0)
            MO_index.append(a)
            spin_state.append(1)
        elif i == 'u':
            MO_index.append(a)
            spin_state.append(0)
        elif i == 'd':
            MO_index.append(a)
            spin_state.append(1)
    return(MO_index,spin_state)



def Molcas_to_Wavepack(molcas_h5file, up_down_file, inactive, cut_states):
    '''
    This is intended to convert Molcas generated hdf5 file data (rasscf) to the format
    used by pydensity.

    molcas_h5file :: h5 file object
    up_down_file :: FilePath
    inactive :: Int <- number of inactive orbital in the casscf problem
    cut_states :: Int  <- number of states you want to consider

    returns the set of data arrays
    '''

    print("Getting CI vectors data")
    _ , ci_length = molcas_h5file['CI_VECTORS'].shape
    ci_coefficients = np.asarray(molcas_h5file['CI_VECTORS'][:cut_states]).swapaxes(0,1).flatten() # I need this vector flattened
    MO_index, spin_state = string_active_space_transformer(up_down_file, inactive)

    basis_f_id = molcas_h5file['BASIS_FUNCTION_IDS']
    primi_id = molcas_h5file['PRIMITIVE_IDS']


    # PARSE THINGS
    print("Getting MO Occupation and electron data")

    MO_OCCUPATIONS = np.asarray(molcas_h5file['MO_OCCUPATIONS'])
    n_electrons = int(sum(MO_OCCUPATIONS))


    n_mo = MO_OCCUPATIONS[np.nonzero(MO_OCCUPATIONS)].size
    print("Getting nuclear data")
    nucl_index = np.asarray(basis_f_id[:,0]) # THIS NEEDS TO BE np.array([])
    nucl_coord = np.asarray(molcas_h5file['CENTER_COORDINATES']) # THIS NEEDS TO BE np.array([])
    print("Getting spherical harmonics data")
    bas_fun_type = np.asarray(basis_f_id[:,1:3],dtype=np.int32) # THIS NEEDS TO BE np.array([])
    n_states_neut = molcas_h5file['ROOT_ENERGIES'][:cut_states].size # this is ok

    '''
    Now we need to compute the transition density matrix. transition density
    matrix requires the ci vector,the array containing the occupied mos and
    the spin state vector.
    '''

    n_active = n_mo - inactive

    tran_den_mat = np.zeros(n_mo*n_mo*n_states_neut*n_states_neut)
    print("Entering TDM: building routine")
    spher.pbuild_transition_density_matrix(
            n_states_neut,
            inactive,
            n_active,
            ci_length,
            n_electrons,
            ci_coefficients,
            MO_index,
            spin_state,
            tran_den_mat
            )
    print("TDM Built!")

    np.save("testing_tdm",tran_den_mat)
    tran_den_mat = tran_den_mat.reshape((n_states_neut*n_states_neut,n_mo*n_mo))

    '''
    We want to evaluate the contraction numbers for every basis function.
    each basis function is described by CENTER - SHELL - L - ML
    for each of them, the number of contractions is given by the number
    of corresponding primitives with the same CENTER - SHELL - L
    we just need then to compute this number
    We also track the id of every primitive involved in the basis function array in cont_id
    '''

    cont_num = np.zeros((basis_f_id).shape[0],dtype=int)
    cont_id = []

    for i in np.arange(0,np.asarray(basis_f_id).shape[0]):
            for j in np.arange(0,np.asarray(primi_id).shape[0] ):
                if( basis_f_id[i][0] == primi_id[j][0] and basis_f_id[i][1] == primi_id[j][2] and basis_f_id[i][2] == primi_id[j][1]):
                    cont_num[i] += 1
            cont_id.append(np.zeros(cont_num[i],dtype=int))
            tot = 0
            for j in np.arange(0,np.asarray(primi_id).shape[0] ):
                if( basis_f_id[i][0] == primi_id[j][0] and basis_f_id[i][1] == primi_id[j][2] and basis_f_id[i][2] == primi_id[j][1]):
                    cont_id[i][tot] = j
                    tot = tot+1

    '''
    The maximum contraction number gives us the size of dimension 1 for
    the arrays cont_zeta and cont_coeff
    '''

    cont_zeta = np.zeros((basis_f_id.shape[0],cont_num.max()))
    cont_coeff = np.zeros((basis_f_id.shape[0],cont_num.max()))

    '''
    We need to fill cont_zeta and cont_coeff now. These numbers are given, for
    every contraction in the PRIMITIVES array. The difficulty is that we should
    fill the arrays with the values respective to the corresponding primitive.
    We assume that the primitives are used in the same order as they are called
    in the BASIS_FUNCTION_IDS array
    '''

    for i in np.arange(0,(basis_f_id).shape[0]):
        for j in np.arange(0,cont_num[i]):
            cont_zeta[i,j] = np.asarray(molcas_h5file['PRIMITIVES'])[cont_id[i][j],0]
            cont_coeff[i,j] = np.asarray(molcas_h5file['PRIMITIVES'])[cont_id[i][j],1]
            cont_coeff[i,j] = cont_coeff[i,j]/((0.5*intplushalf_gamma(bas_fun_type[i,0]+1)/(2*cont_zeta[i,j])**(bas_fun_type[i,0]+1.5))**0.5);
#    cont_zeta=np.asarray(molcas_h5file['PRIMITIVES'])[:,0]
#    cont_coeff=np.asarray(molcas_h5file['PRIMITIVES'])[:,1]

    lcao_coeff_array = np.asarray(molcas_h5file['MO_VECTORS']).reshape((basis_f_id.shape[0],basis_f_id.shape[0]))
    lcao_num_array = lcao_coeff_array.shape[0]

    return n_mo,nucl_index,nucl_coord,bas_fun_type,n_states_neut,tran_den_mat,cont_num,cont_zeta,cont_coeff,lcao_num_array,lcao_coeff_array

def pickleLoad(fn):
    '''
    tedious to remember protocol flag and stuffs
    fn :: FilePath
    '''
    return pickle.load(open(fn,'rb'))

def pickleSave(fn,thing):
    '''
    tedious part 2
    fn :: FilePath
    thing :: Structure to save
    '''
    with open(fn, "wb" ) as pickle_file:
        pickle.dump(thing, pickle_file, protocol=pickle.HIGHEST_PROTOCOL)


def main(molcas_h5file_path,updown_file,target_file,inactive,cut_states):
    '''
    molcas_h5file_path :: Filepath <- h5 of Molcas
    updown_file :: Filepath <- input up and down file
    target_file :: Filepath <- output cube
    inactive :: Int <- inactive orbitals
    cut_states :: Int <- number of states
    '''

    # I remove the extension from h5 and put pickle one
    pickle_file_name = os.path.splitext(molcas_h5file_path)[0] + '.pickle'

    # if pickle file exists, read it, if not, create it with Molcas_to_Wavepack.
    if os.path.isfile(pickle_file_name):
        print('\nI see Pickle file {}\n'.format(pickle_file_name))
        n_mo,nucl_index,nucl_coord,bas_fun_type,n_states_neut,tran_den_mat,cont_num,cont_zeta,cont_coeff,lcao_num_array,lcao_coeff_array = pickleLoad(pickle_file_name)
    else:
        molcas_h5file = h5.File(molcas_h5file_path, 'r')
        print("Entering Molcas To Wavepack Routine")
        return_tuple = Molcas_to_Wavepack(molcas_h5file,updown_file,inactive,cut_states)
        print("Molcas To Wavepack Routine Done!")
        molcas_h5file.close()

        # unpack the data in name variables and save as pickle
        print('\nWriting file {}\n'.format(pickle_file_name))

        pickleSave(pickle_file_name,return_tuple)

        n_mo,nucl_index,nucl_coord,bas_fun_type,n_states_neut,tran_den_mat,cont_num,cont_zeta,cont_coeff,lcao_num_array,lcao_coeff_array = return_tuple

    print('Writing cube {}'.format(target_file))

    nes = n_states_neut

    '''
    wvpck_data represent the amplitude on the electronic states for the considered time.
    it is an array with size nes is single point, and a matrix with size nes x ngeom if
    geometry dependent
    '''

    wvpck_data = np.zeros(nes)
    wvpck_data[6] = 1

    '''
    tdm is the transition density matrix in the basis of mo's, averagred over the populations
    in the excited states.
    '''

    tdm = np.zeros((n_mo,n_mo))

    for ies in np.arange(0,nes):
        tdm = tdm+abs(wvpck_data[ies])**2*tran_den_mat[(ies)*n_states_neut+(ies)].reshape((n_mo,n_mo))
        for jes in np.arange(ies+1,nes):
#            print(ies,jes,"are the es")
            tdm = tdm+2*((wvpck_data[ies]*wvpck_data[jes].conjugate()).real)*tran_den_mat[(ies)*n_states_neut+(jes)].reshape((n_mo,n_mo))

    '''
    once you computed the averaged tdm, you just need to evaluate the density
    this is a box centered in the origin 0,0,0
    '''

    xmin = -10.0
    ymin = -10.0
    zmin = -10.0
    dx = 0.31746032
    dy = 0.31746032
    dz = 0.31746032
    nx = 64
    ny = 64
    nz = 64
    lcao_num = lcao_num_array
    cube_array = np.zeros((nx,ny,nz))
    for ix in np.arange(0,nx):
#            print(ix,"/",nx)
        x = xmin+ix*dx
        for iy in np.arange(0,ny):
            y = ymin+iy*dy
            for iz in np.arange(0,nz):
                z = zmin+iz*dz

                val = 0
#                lcao_num = len(lcao_num_array[0])
#                lcao_num = molcas_h5file['BASIS_FUNCTION_IDS'].shape
                coord = np.array([x,y,z])
                coordp = coord-nucl_coord[nucl_index-1]
                rp = np.zeros(lcao_num)
                tp = np.zeros(lcao_num)
                fp = np.zeros(lcao_num)
                xp = coordp.T[0]
                yp = coordp.T[1]
                zp = coordp.T[2]
                xp = xp.copy(order='C')
                yp = yp.copy(order='C')
                zp = zp.copy(order='C')
                rp = rp.copy(order='C')
                tp = tp.copy(order='C')
                fp = fp.copy(order='C')

                spher.pcart_to_spher(xp,yp,zp,rp,tp,fp)
                r,t,f = rp.T,tp.T,fp.T
                angular = np.zeros(lcao_num)
                l = bas_fun_type.T[0]
                ml = bas_fun_type.T[1]
                l = l.copy(order='C')
                ml = ml.copy(order='C')
                angular = angular.copy(order='C')
                spher.pspher_harmo(t,f,l,ml,angular)

                i = np.arange(0,n_mo)
                phii = mo_value(r,t,f,i,nucl_index,nucl_coord,bas_fun_type,cont_num,cont_zeta,cont_coeff,lcao_num_array,lcao_coeff_array,angular)

                val = np.dot(phii.T,np.matmul(tdm,phii))

                cube_array[ix][iy][iz] = cube_array[ix][iy][iz]+val
#                    print(val,ix,iy,iz)

    cubegen(xmin,ymin,zmin,dx,dy,dz,nx,ny,nz,target_file,cube_array,nucl_coord)


if __name__ == "__main__" :

    # on MAC
    #updown_file = '/Users/stephan/dox/Acu-Stephan/up_down'
    #molcas_h5file_path = '/Users/stephan/dox/Acu-Stephan/zNorbornadiene_P005-000_P020-000_P124-190.rasscf.h5'
    #target_file = "/Users/stephan/Desktop/density_test_alessio_.cub"


    # ON SASHA
    updown_file = '/home/alessio/config/Stephan/up_down'
    molcas_h5file_path = '/home/alessio/config/Stephan/zNorbornadiene_P000-000_P017-136_P114-766.rasscf.h5'
    target_file = '/home/alessio/config/Stephan/density_test_alessio_done.cube'

    inactive = 23
    cut_states = 8

    main(molcas_h5file_path,updown_file,target_file,inactive,cut_states)


